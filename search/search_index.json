{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Sourcemeta JSON Schema Registry","text":"<p>A high-performance, self-hosted JSON Schema registry that transforms your existing Git repositories of schemas into searchable, discoverable schema catalogs with enterprise-grade governance capabilities.</p> <p></p> <p>About Us</p> <p>Sourcemeta is led by a member of the JSON Schema Technical Steering Committee. We are consultants, O'Reilly book authors, award-winning researchers, and open-source maintainers in the JSON Schema ecosystem.  With us, you get unmatched specification compliance and battle-tested expertise that you simply won't find elsewhere.</p> <p>Some of our other projects include Blaze (ultra high-performance JSON Schema compiler), JSON Schema CLI (the most comprehensive JSON Schema command-line tool), and LearnJSONSchema.com (the most popular JSON Schema reference documentation site).</p> <p>Check out a live public example instance of the Sourcemeta Registry at schemas.sourcemeta.com.</p>"},{"location":"#use-cases","title":"Use Cases","text":"<p>Schema Catalog: Most organisations have JSON Schemas scattered across Git repositories with broken frontends, duct-tape integrations, or no discoverability at all. The Sourcemeta Registry sits on top of your existing repositories and transforms them into a unified, searchable catalog where teams can discover, browse, consume, and understand your data contracts.</p> <p>API Governance: Establish organisation-wide standards for API design by centralizing schema management, easily consuming external JSON Schema data models, tracking schema quality, and ensuring consistency across teams and services.</p> <p>Tooling Infrastructure: API and schema tooling companies can embed the Registry as a foundational component in their own products. For example, OpenAPI editors and developer platforms can leverage Sourcemeta's advanced schema technology through the Registry's HTTP API to power their schema-related features (such as offering built-in schema collections to their end users) without building complex JSON Schema infrastructure from scratch.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> GitOps-Native Easy setup from your   existing Git repositories.  Governance-friendly by design\u2014all schema changes   go through Git approval workflows</li> <li> Web Explorer Search and browse schemas across   your organisation from an intuitive web interface. Disable for headless   API-only deployments</li> <li> Editor Integration Edit schemas in your IDE with   full autocomplete support. Automatically accommodates Visual Studio Code   quirks   like broken auto-completion of   meta-schemas</li> <li> Schema Health Checks Monitor and guarantee schema best   practices with comprehensive built-in linting. The most advanced JSON Schema   linter available, designed with input from the JSON Schema organisation</li> <li> Rich HTTP API High-performance programmatic access for   CI/CD pipelines, tooling integration, and custom workflows. Check out the   documentation to learn more</li> <li> Built-in Schema Collections Curated   schemas from industry leaders eliminate fragile copy-pasting of   upstream schemas</li> <li> JSON Schema Compatibility Full support for JSON   Schema Draft 4, Draft 6, Draft 7, 2019-09, and 2020-12, plus custom   meta-schemas, Standard Output   Formats,   annotation collection, JSON Schema   Bundling,   and more</li> <li> High Performance Written in C++, delivering exceptional   performance with minimal compute resources. Run instances on modest hardware,   reducing infrastructure costs while maintaining enterprise-scale throughput   with a stateless horizontally-scalable design</li> </ul>"},{"location":"#enterprise-ready","title":"Enterprise Ready","text":"<p>Zero-dependency deployment: Maintain complete control over your schema data with straightforward deployment without any additional runtime dependency such as databases. Perfect for highly-regulated industries, compliance requirements, and airgapped environments where every dependency creates security and operational risk.</p> <p>Source-available: The Registry is source-available (though not open-source) on GitHub, providing complete code transparency for security audits, compliance reviews, internal assessments, and modification. Enterprises can examine every line of code, eliminating black-box concerns and ensuring no vendor lock-in. If Sourcemeta would ever cease operations, you retain full access to continue running and maintaining your Registry instances.</p> <p>Expert commercial support &amp; training: Commercial Licenses give you access to world-class JSON Schema expertise whenever you need it. Upon request, we provide managed hosting, and we also offer advanced tailored consultancy and training programs to elevate your team's schema design capabilities. Reach out to discuss further!</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>As an early-stage bootstrapped startup, we're rapidly implementing new capabilities, but the current Registry represents just the beginning of our vision. Your feedback is crucial in helping us build the schema management solution the industry needs.</p> <ul> <li>Automatic schema upgrades and downgrades: Seamlessly serve your schemas   in any JSON Schema version that external tools require, eliminating manual   conversion headaches</li> <li>Schema evolution and transforms: Convert data between schema versions and   formats. Includes schema evolution (i.e. v1 to v2) to arbitrary data   transformations (i.e. Celsius to Fahrenheit)</li> <li>Standard Library of Schemas: Expertly crafted OEM schema collections   covering diverse domains, so that you can stop reinventing the wheel and   build other schemas and API specifications on proven foundations</li> <li>Step-through Online Schema Debugger: Visual schema evaluation debugger   that highlights validation logic line-by-line in both schema and instance   data for faster troubleshooting</li> <li>Documentation Generation: Human-readable schema documentation that   business teams and non-technical stakeholders can easily understand</li> <li>Specification Support: Native ingestion of OpenAPI, AsyncAPI, SDF, W3C   Web of Things, and other specifications that embed JSON Schema, with the full   benefits of the Registry</li> <li>Gateway Functionality: Structured Output LLM negotiation, API   specification testing proxy, data ingestion endpoints, and other advanced   validation gateway capabilities (such as dynamically testing strictness of   schemas against runtime data)</li> </ul> <p>Do you have other needs? Don't hesitate in writing to us any time. We are friendly!</p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Ready to transform your scattered schemas into a powerful discovery platform? Head over to the Getting Started guide and get up and running in minutes.</p>"},{"location":"api/","title":"HTTP API","text":"<p>This API has been architected with performance as a primary consideration, ensuring fast response times and efficient resource utilization across all endpoints.</p> <ul> <li>Cross-origin resource sharing (CORS): Full CORS support is implemented   throughout the API, including proper handling of preflight <code>OPTIONS</code>   requests, making it seamlessly compatible with browser-based applications and   cross-origin requests</li> <li>HTTP conventions: Every <code>GET</code> request has a corresponding <code>HEAD</code> method.   For brevity, we don't specify this every time</li> <li>Errors: Error responses follow the RFC 7807 Problem   Details specification for   consistent, machine-readable error information</li> <li>Schema Documentation: While we don't provide an OpenAPI specification due   to its current limitations with multi-fragment path support (see OpenAPI   Issue #2653) which   make describing this API impossible, the Registry itself is comprehensively   defined using JSON Schemas.  For complete API schema definitions, mount the   built-in <code>@sourcemeta/registry</code> schema collection to your   Registry instance</li> </ul>"},{"location":"api/#general","title":"General","text":""},{"location":"api/#list","title":"List","text":"<p>This endpoint lists the contents of a directory within the Registry at the specified <code>{path}</code> parameter.</p> <pre><code>GET /self/api/list/{path?}\n</code></pre> <p>If no path is provided, the endpoint returns the contents of the root directory. The response includes all schemas and subdirectories available at the requested path, providing a hierarchical view of the registry structure for navigation and discovery purposes.</p> 200404 Property Type Required Description <code>/url</code> String Yes The absolute URL of the directory <code>/path</code> String Yes The relative URL of the directory <code>/breadcrumb</code> Array Yes The breadcrumb of the directory entry <code>/breadcrumb/*/name</code> String Yes The breadcrumb entry URL path segment <code>/breadcrumb/*/url</code> String Yes The relative URL of the breadcrumb location <code>/title</code> String No The title associated with the directory <code>/description</code> String No The description associated with the directory <code>/email</code> String No The e-mail address associated with the directory <code>/github</code> String No The GitHub organisation or repository associated with the directory <code>/website</code> String No The external URL associated with the directory <code>/entries</code> Array Yes The entries inside the directory <code>/entries/*/type</code> String Yes The type of the entry (<code>schema</code> or <code>directory</code>) <code>/entries/*/name</code> String Yes The last URL path segment of the entry <code>/entries/*/path</code> String Yes The relative URL of the entry <code>/entries/*/health</code> Integer No The aggregated health of the entry <code>/entries/*/title</code> String No The title associated with the entry <code>/entries/*/description</code> String No The description associated with the entry <code>/entries/*/email</code> String No For <code>directory</code> entries, the e-mail address associated with the entry <code>/entries/*/github</code> String No For <code>directory</code> entries, the GitHub organisation or repository associated with the entry <code>/entries/*/website</code> String No For <code>directory</code> entries, the website URL associated with the entry <code>/entries/*/dependencies</code> Integer Yes For <code>schema</code> entries, the number of direct and indirect dependencies of the schema <code>/entries/*/bytes</code> Integer No For <code>schema</code> entries, the bytes that the entry occupies <code>/entries/*/baseDialect</code> String No For <code>schema</code> entries, the base dialect URI of the entry <code>/entries/*/dialect</code> String No For <code>schema</code> entries, the dialect URI of the entry <code>/entries/*/identifier</code> String No For <code>schema</code> entries, the absolute URI of the entry <code>/entries/*/alert</code> String / Null No For <code>schema</code> entries, the human readable alert message for the schema collection <code>/entries/*/provenance</code> String / Null No For <code>schema</code> entries, the origin of the schema collection, if any <p>The directory does not exist.</p>"},{"location":"api/#schemas","title":"Schemas","text":""},{"location":"api/#fetch","title":"Fetch","text":"<p>This endpoint fetches the JSON Schema located at the <code>{path}</code> parameter.</p> <pre><code>GET /{path}[.json][?bundle=1]\n</code></pre> <p>The <code>.json</code> extension is optional unless the HTML UI is enabled and the <code>Accept</code> header is set to prefer an HTML response.  If the <code>bundle</code> query parameter is set, the schema references are embedded using the standard JSON Schema Bundling process.</p> 200404405 <p>The schema as JSON.</p> <p>The schema does not exist.</p> <p>The configuration file marks the schema collection as listed but not served.</p>"},{"location":"api/#evaluate","title":"Evaluate","text":"<p>This endpoint takes a JSON instance as a request body and evaluates it against the JSON Schema located at the <code>{path}</code> parameter.</p> <pre><code>POST /self/api/schemas/evaluate/{path}\n</code></pre> <p>Perform exhaustive JSON Schema evaluation (including annotation collection) and respond back using the Basic JSON Schema Standard Output Format.</p> 200400404405 <p>See JSON Schema Standard Output Formats.</p> <p>You must pass an instance to validate against.</p> <p>The schema does not exist.</p> <p>The configuration file excludes evaluation for this schema, or the configuration file marks the schema collection as listed but not served.</p>"},{"location":"api/#trace","title":"Trace","text":"<p>This endpoint takes a JSON instance as a request body and evaluates it against the JSON Schema located at the <code>{path}</code> parameter.</p> <pre><code>POST /self/api/schemas/trace/{path}\n</code></pre> <p>Unlike standard schema validation, this endpoint performs a detailed trace evaluation that exposes the complete internal validation process, including each step, rule application, and decision point that occurs during schema processing. This granular visibility into the validation workflow makes it particularly valuable for debugging complex schema issues, understanding validation failures, and for developers building JSON Schema tooling who need insight into the validation engine's behavior and logic flow.</p> 200400404405 Property Type Required Description <code>/valid</code> Boolean Yes Whether evaluation succeeded or not <code>/steps</code> Array Yes The evaluation steps that took place <code>/steps/*</code> Object Yes Each evaluation step that took place <code>/steps/*/type</code> <code>push</code> / <code>pass</code> / <code>fail</code> Yes The type of the step entry <code>/steps/*/message</code> String Yes A description of the step <code>/steps/*/evaluatePath</code> String Yes The evaluate path as a JSON Pointer <code>/steps/*/keywordLocation</code> String Yes The absolute keyword location as a URI <code>/steps/*/instanceLocation</code> String Yes The instance location as a JSON Pointer <code>/steps/*/name</code> String Yes The internal name of the step <code>/steps/*/vocabulary</code> String / Null Yes The vocabulary URI that defines the keyword, if any <code>/steps/*/annotation</code> JSON / Null Yes The annotation value produced by the step, if any <code>/steps/*/instancePositions</code> Array Yes The instance line positions associated with the step <code>/steps/*/instancePositions/0</code> Integer Yes Starting line number <code>/steps/*/instancePositions/1</code> Integer Yes Starting column number <code>/steps/*/instancePositions/2</code> Integer Yes Ending line number <code>/steps/*/instancePositions/3</code> Integer Yes Ending column number <p>You must pass an instance to validate against.</p> <p>The schema does not exist.</p> <p>The configuration file excludes evaluation for this schema, or the configuration file marks the schema collection as listed but not served.</p>"},{"location":"api/#metadata","title":"Metadata","text":"<p>This endpoint retrieves metadata information about the JSON Schema located at the <code>{path}</code> parameter.</p> <pre><code>GET /self/api/schemas/metadata/{path}\n</code></pre> 200404 Property Type Required Description <code>/path</code> String Yes The relative URL of the schema <code>/identifier</code> String Yes The absolute URI of the schema <code>/dialect</code> String Yes The dialect URI of the schema <code>/baseDialect</code> String Yes The base dialect URI of the schema <code>/health</code> Integer Yes The health score of the schema <code>/dependencies</code> Integer Yes The number of direct and indirect dependencies of the schema <code>/bytes</code> Integer Yes The bytes that the schema occupies <code>/alert</code> String / Null No The human readable alert message for the schema collection, if any <code>/title</code> String No The title of the schema, if any <code>/description</code> String No The description of the schema, if any <code>/examples</code> Array Yes Up to 10 of the schema examples, if any <code>/breadcrumb</code> Array Yes The breadcrumb of the schema <code>/breadcrumb/*/name</code> String Yes The breadcrumb entry URL path <code>/breadcrumb/*/path</code> String Yes The relative URL of the breadcrumb location <p>The schema does not exist.</p>"},{"location":"api/#search","title":"Search","text":"<p>This endpoint searches for JSON Schemas based on the provided query <code>{term}</code>.</p> <pre><code>GET /self/api/schemas/search?q={term}\n</code></pre> <p>Note that the this endpoint has a hard limit of 10 results.</p> 200 Property Type Required Description <code>/*/path</code> String Yes The relative URL of the schema <code>/*/title</code> String No The title of the schema (may be an empty string) <code>/*/description</code> String No The description of the schema (may be an empty string)"},{"location":"api/#dependencies","title":"Dependencies","text":"<p>This endpoint retrieves all direct and indirect dependencies of the JSON Schema located at the specified <code>{path}</code> parameter.</p> <pre><code>GET /self/api/schemas/dependencies/{path}\n</code></pre> 200404 Property Type Required Description <code>/*/from</code> String Yes The absolute URL of the schema that originates the dependency <code>/*/to</code> String Yes The absolute URL of the schema being referenced <code>/*/at</code> String Yes The JSON Pointer to the schema location where the dependency originates <p>The schema does not exist.</p>"},{"location":"api/#health","title":"Health","text":"<p>This endpoint retrieves the health analysis and score for the JSON Schema located at the specified <code>{path}</code> parameter.</p> <pre><code>GET /self/api/schemas/health/{path}\n</code></pre> 200404 Property Type Required Description <code>/score</code> Integer Yes The overall health score of the schema (0 to 100) <code>/errors</code> Array Yes Array of health issues found in the schema <code>/errors/*/pointers</code> Array Yes The paths where the issue occurs <code>/errors/*/pointers/*</code> String Yes A JSON Pointer path of where the issue occurs <code>/errors/*/name</code> String Yes The identifier name of the health issue <code>/errors/*/message</code> String Yes Human-readable description of the issue <code>/errors/*/description</code> String / Null No Additional description (may be null) <p>The schema does not exist.</p>"},{"location":"api/#locations","title":"Locations","text":"<p>This endpoint retrieves metadata about every URI associated with the JSON Schema located at the specified <code>{path}</code> parameter, including schema resources, subschemas, anchors, and more.</p> <pre><code>GET /self/api/schemas/locations/{path}\n</code></pre> 200404405 Property Type Required Description <code>/static</code> Object Yes Static URI locations within the schema <code>/static/*</code> Object Yes Metadata for a specific URI location <code>/static/*/base</code> String Yes The base URI of the location <code>/static/*/baseDialect</code> String Yes The base dialect of the schema <code>/static/*/dialect</code> String Yes The JSON Schema dialect URI <code>/static/*/parent</code> String / Null No The parent JSON Pointer (if any) <code>/static/*/pointer</code> String Yes The JSON Pointer to this location from the root of the schema <code>/static/*/relativePointer</code> String Yes The relative JSON Pointer from its nearest base URI <code>/static/*/root</code> String Yes The root URI of the schema <code>/static/*/type</code> String Yes The type of location <code>/static/*/position</code> Array Yes The entry location positions <code>/static/*/position/0</code> Integer Yes Starting line number <code>/static/*/position/1</code> Integer Yes Starting column number <code>/static/*/position/2</code> Integer Yes Ending line number <code>/static/*/position/3</code> Integer Yes Ending column number <code>/dynamic</code> Object Yes Dynamic URI locations within the schema <code>/dynamic/*</code> Object Yes Metadata for a specific URI location <code>/dynamic/*/base</code> String Yes The base URI of the location <code>/dynamic/*/baseDialect</code> String Yes The base dialect of the schema <code>/dynamic/*/dialect</code> String Yes The JSON Schema dialect URI <code>/dynamic/*/parent</code> String / Null No The parent URI (if any) <code>/dynamic/*/pointer</code> String Yes The JSON Pointer to this location from the root of the schema <code>/dynamic/*/relativePointer</code> String Yes The relative JSON Pointer from its nearest base URI <code>/dynamic/*/root</code> String Yes The root URI of the schema <code>/dynamic/*/type</code> String Yes The type of location <code>/dynamic/*/position</code> Array Yes The entry location positions <code>/dynamic/*/position/0</code> Integer Yes Starting line number <code>/dynamic/*/position/1</code> Integer Yes Starting column number <code>/dynamic/*/position/2</code> Integer Yes Ending line number <code>/dynamic/*/position/3</code> Integer Yes Ending column number <p>The schema does not exist.</p> <p>The configuration file marks the schema collection as listed but not served.</p>"},{"location":"api/#stats","title":"Stats","text":"<p>This endpoint retrieves keyword statistics, by vocabulary, about every URI associated with the JSON Schema located at the specified <code>{path}</code> parameter.</p> <pre><code>GET /self/api/schemas/stats/{path}\n</code></pre> 200404405 Property Type Required Description <code>/&lt;vocabulary&gt;/&lt;keyword&gt;</code> Integer Yes The number of occurrences keywords of a specific keyword name from a specific vocabulary (or <code>unknown</code> otherwise) <p>The schema does not exist.</p> <p>The configuration file marks the schema collection as listed but not served.</p>"},{"location":"api/#positions","title":"Positions","text":"<p>This endpoint retrieves line and column position information for every token in the JSON Schema located at the specified <code>{path}</code> parameter.</p> <pre><code>GET /self/api/schemas/positions/{path}\n</code></pre> <p>The result is a JSON object where every property is JSON Pointer to the given schema.</p> 200404405 Property Type Required Description <code>/*/0</code> Integer Yes Starting line number <code>/*/1</code> Integer Yes Starting column number <code>/*/2</code> Integer Yes Ending line number <code>/*/3</code> Integer Yes Ending column number <p>The schema does not exist.</p> <p>The configuration file marks the schema collection as listed but not served.</p>"},{"location":"commercial/","title":"Buy a Commercial License","text":"<p>Ready to scale your JSON Schema management? Our commercial licensing ensures you have the tools and support needed for enterprise deployments while contributing to the continued development of industry-leading JSON Schema technology.</p> <p>The Sourcemeta JSON Schema Registry is publicly available on GitHub with full source code transparency, enabling comprehensive auditing and community contributions. While the codebase is accessible for review and collaboration, the Registry operates under a source-available license rather than a traditional open-source model.</p>"},{"location":"commercial/#editions","title":"Editions","text":"<p>You can use the Registry at no cost with all features included for non-commercial and evaluation purposes. However, commercial deployments require a license from Sourcemeta. This licensing model enables us</p> <ul> <li>Maintain and enhance the Registry's advanced capabilities</li> <li>Provide enterprise-grade support and reliability</li> <li>Continue investing in cutting-edge JSON Schema tooling development</li> </ul>"},{"location":"commercial/#our-commitment-to-excellence","title":"Our Commitment to Excellence","text":"<p>Sourcemeta is led by a member of the JSON Schema Technical Steering Committee, ensuring our solutions meet the highest industry standards and remain aligned with JSON Schema ecosystem developments. As an independent, bootstrapped company without venture capital backing, we maintain complete focus on delivering nothing less than exceptional JSON Schema tooling.</p>"},{"location":"commercial/#next-steps","title":"Next Steps","text":"<p>Interested in a commercial license? Contact us at hello@sourcemeta.com to discuss further.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>The Sourcemeta Registry is designed around a GitOps workflow: all of its behavior is determined by the configuration file documented here, and runtime changes are not permitted. This ensures that your Registry instance is fully reproducible, auditable, and version-controlled, just like any other part of your infrastructure.</p> <p>Success</p> <p>Because the Registry is entirely configured at build time (with changes applied only via a redeployment), it achieves significant performance advantages. Schemas are pre-optimized at build time, and the service itself is fully stateless, enabling effortless horizontal scaling and predictable performance under load.</p> <p>This configuration file is designed to give you complete freedom to structure your Registry instance in a way that best suits your organization. Compared to many other schema registry solutions, it imposes no artificial constraints on hierarchy, versioning, or schema organization. You can version and arrange your schemas however you like: by department, by function, in a flat structure, or in any other way you can think of. This allows your instance to reflect your company's needs rather than a pre-defined model.</p> <p>Note</p> <p>By convention, the name of the configuration file is <code>registry.json</code>.</p> <p>The JSON Schema that defines <code>registry.json</code> can be mounted in the Registry as a built-in collection called <code>@sourcemeta/registry</code>. You can explore the latest version at https://schemas.sourcemeta.com/sourcemeta/registry/configuration.</p> <p>Tip</p> <p>A great way to learn what's possible is to explore the configuration file of the schemas.sourcemeta.com public example instance, which you can find on GitHub</p>"},{"location":"configuration/#registryjson","title":"<code>registry.json</code>","text":"<p>The configuration file controls your entire Registry instance through various top-level properties that define both global settings and content structure. For representing the contents of the Registry, this file uses a hierarchical tree approach where you organise the contents of your Registry using nested nodes.  Each node in this tree serves as either a Collection (containing actual schemas) or a Page (acting as a directory that groups other pages and schema collections), giving you complete flexibility in structuring your instance.</p> <p>Note</p> <p>While any content tree structure is supported, you cannot create a top-level entry called <code>self</code>, as this namespace is reserved for the Registry API and other internal functionality.</p> Property Type Required Default Description <code>/url</code> String Yes N/A The absolute URL on which the Registry will be served. The Registry will automatically add URI identifiers relative to this URL for every ingested schema <code>/extends</code> Array No None One or more configuration files to extend from. See the Extends section for more information <code>/contents</code> Object No None The top-level Collections and Pages that compose the Registry instance <code>/html</code> Object or Boolean No <code>{}</code> Settings for the HTML explorer. If set to <code>false</code>, the Registry runs in headless mode. See the HTML section for more details <p>For example, a minimal Registry configuration that mounts a single schema collection (<code>./schemas</code>) at URL <code>https://schemas.example.com/my-first-collection</code> may look like this, and a schema at <code>./schemas/foo.json</code> will be available at <code>https://schemas.example.com/my-first-collection/foo.json</code>:</p> registry.json<pre><code>{\n  \"url\": \"https://schemas.example.com\",\n  \"contents\": {\n    \"my-first-collection\": {\n      \"path\": \"./schemas\"\n    }\n  }\n}\n</code></pre>"},{"location":"configuration/#html","title":"HTML","text":"<p>When enabled through the optional <code>html</code> top-level property, the Registry generates an HTML explorer interface. Unlike the JSON API, this explorer provides a user-friendly web interface for browsing and examining your schemas.  You can customize the explorer's appearance and behavior using the configuration options detailed below.</p> Property Type Required Default Description <code>/name</code> String No Sourcemeta The concise name of the Registry instance. For example, the name of your organisation. This will be shown in the navigation bar in the HTML explorer <code>/description</code> String No The next-generation JSON Schema Registry A longer description of the Registry instance. This will be shown in HTML meta tags <code>/head</code> String No None An HTML snippet to include in the <code>&lt;head&gt;</code> section of the HTML explorer. Useful for website analytics purposes or for custom styles <code>/hero</code> String No None An HTML snippet to render in the front page of the Registry. Try to make this snippet as standalone as possible using <code>style</code> HTML attributes <code>/action</code> Object No None A call-to-action button to render in the navigation bar of the HTML explorer <code>/action/title</code> String Yes N/A The text of the call-to-action button <code>/action/icon</code> String Yes N/A The icon name of the call-to-action button, which must match the name of an icon in the Bootstrap Icons collection <code>/action/url</code> String Yes N/A The absolute URL of the call-to-action button"},{"location":"configuration/#collections","title":"Collections","text":"<p>A schema collection functions as a curated set of schemas that the Registry instance ingests and serves at a specified location. Unlike pages, schema collections contain the actual schema definitions that power your registry.</p> <p>The Registry supports JSON Schema Draft 4, Draft 6, Draft 7, 2019-09, and 2020-12; and custom meta-schemas based on those dialects.</p> <p>Warning</p> <p>The Registry maintains data integrity by rejecting any schemas that fail against their meta-schemas or that cannot be fully resolved during the ingestion process. For this reason, you may need to explicitly inform the Registry about default dialects, base URIs, or custom overrides for schema reference resolution.</p> <p>If you are facing any difficulties with this, don't hesitate in asking for help using GitHub Discussions. We are here to help!</p> <p>Note</p> <p>To consolidate differences across operating systems, the Sourcemeta Registry assumes the file system is case-insensitive and will not distinguish between two schema URIs that only differ in casing. Furthermore, URI paths will be turned into lowercase.</p> Property Type Required Default Description <code>/path</code> String Yes (unless <code>includes</code> is set) N/A The path (relative to the location of the configuration file) to the directory which includes the schemas for this collection. The directory will be recursively traversed in search of <code>.json</code>, <code>.yaml</code>, or <code>.yml</code> schemas <code>/baseUri</code> String No The <code>file://</code> URI of the configuration directory The base URI of every schema file that is part of this collection, for rebasing purposes. If a schema defines an explicit identifier that is not relative to this base URI, the generation of the Registry will fail <code>/defaultDialect</code> String No None The default JSON Schema dialect URI to use for schemas that do not declare the <code>$schema</code> keyword <code>/title</code> String No None The concise title of the schema collection <code>/description</code> String No None A longer description of the schema collection <code>/email</code> String No None The e-mail address associated with the schema collection <code>/github</code> String No None The GitHub organisation or <code>organisation/repository</code> identifier associated with the schema collection <code>/website</code> String No None The absolute URL to the website associated with the schema collection <code>/includes</code> String No None A <code>jsonschema.json</code> manifest definition to include in-place. See the Includes section for more information. If this property is set, none of the other properties can be set (including <code>path</code>) <code>/resolve</code> Object No None A URI-to-URI map to hook into the schema reference resolution process. See the Resolve section for more information <code>/x-sourcemeta-registry:evaluate</code> Boolean No <code>true</code> When set to <code>false</code>, disable the evaluation API for this schema collection. This is useful if you will never make use of the evaluation API and want to speed up the generation of the Registry <code>/x-sourcemeta-registry:alert</code> String No N/A When set, provide a human-readable alert on both the API and the HTML explorer for every schema in the collection. This is useful to provide any important message to consumers"},{"location":"configuration/#includes","title":"Includes","text":"<p>The <code>includes</code> property enables modular schema collection management by allowing you to extract collection definitions into separate <code>jsonschema.json</code> files and reference them in-place. Unlike inline definitions, this approach promotes reusability across multiple configuration files while maintaining clean separation of concerns. Each included <code>jsonschema.json</code> file contains the same properties as a standard schema collection definition, with the Registry seamlessly integrating the external file's contents at the specified location during processing. For example:</p> registry.json<pre><code>{\n  \"url\": \"https://schemas.example.com\",\n  \"contents\": {\n    \"my-first-collection\": {\n      \"includes\": \"./jsonschema.json\"\n    }\n  }\n}\n</code></pre> jsonschema.json<pre><code>{\n  \"title\": \"My Schema Collection\",\n  \"path\": \"./schemas\"\n}\n</code></pre> <p>If a directory path is provided to the <code>includes</code> property, the Registry will look for a file called <code>jsonschema.json</code> inside such directory.</p>"},{"location":"configuration/#resolve","title":"Resolve","text":"<p>The <code>resolve</code> property is an advanced feature to hook into the schema reference resolution process. When set, the object translates any reference that equals a property name in the object to the corresponding property value.</p> <p>This is useful when mounting schemas that consume other external schemas and you want to route the reference back into the Registry instance. For example, let's say your schema collection depends on GeoJSON and has various references to its latest official URL: <code>https://geojson.org/schema/GeoJSON.json</code>. Instead of depending on an external resource outside your control, you can configure the Registry to extend from the <code>@geojson/v1.0.5</code> built-in collection and rephrase the <code>https://geojson.org/schema/GeoJSON.json</code> references to consume from the internal version:</p> registry.json<pre><code>{\n  \"url\": \"https://schemas.example.com\",\n  \"extends\": [ \"@geojson/v1.0.5\" ],\n  \"contents\": {\n    \"my-first-collection\": {\n      \"path\": \"./schemas\",\n      \"resolve\": {\n        \"https://geojson.org/schema/GeoJSON.json\": \"/geojson/v1.0.5/geojson.json\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"configuration/#pages","title":"Pages","text":"<p>A page functions as an organizational container within the Registry instance. Unlike schema collections, pages don't contain schemas directly\u2014instead, they group other pages or schema collections together. For instance, you might create a hierarchy of pages representing your organization's teams, where each team page contains the schema collections they own.</p> Property Type Required Default Description <code>/title</code> String No None The concise title of the page <code>/description</code> String No None A longer description of the page <code>/email</code> String No None The e-mail address associated with the page <code>/github</code> String No None The GitHub organisation or <code>organisation/repository</code> identifier associated with the page <code>/website</code> String No None The absolute URL to the website associated with the page <code>/extends</code> Array No None One or more configuration files to extend from. See the Extends section for more information <code>/contents</code> Object No None The nested Collections and Pages inside this page"},{"location":"configuration/#extends","title":"Extends","text":"<p>The <code>extends</code> property enables configuration inheritance, allowing either your top-level schema or individual pages to build upon existing configuration files for enhanced reusability and modularity. This property accepts an array of strings where each entry represents either a file path (relative from the configuration file location) or a built-in schema collection identifier (prefixed with <code>@</code>). For example:</p> registry.json<pre><code>{\n  \"url\": \"https://schemas.example.com\",\n  \"extends\": [ \"@geojson/v1.0.5\", \"../path/to/my/other/config/registry.json\" ]\n}\n</code></pre> <p>If a directory path is provided to the <code>extends</code> property, the Registry will look for a file called <code>registry.json</code> inside such directory.</p> <p>Note</p> <p>The Registry processes these extensions through deep-merging, where each extended configuration file merges into the previous one in sequence, with your top-level configuration file taking final precedence over the combined result.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>The Sourcemeta Registry operates on a two-phase architecture: indexing and serving. During the indexing phase, the Registry scans, analyses, and compiles your schemas. This preprocessing phase creates a highly optimised cache that enables blazing-fast schema retrieval and evaluation during the serving phase.</p> <p>As you will see in this guide, setting up the Sourcemeta Registry is straightforward:</p> <ol> <li>Create a configuration file that sets up your registry    exactly as you want it</li> <li>Create a <code>Dockerfile</code> that extends the slim official base    images and    indexes your schemas at build time</li> <li>Run the optimised registry</li> </ol>"},{"location":"getting-started/#hello-world","title":"Hello World","text":"<p>Got two minutes to spare and Docker installed on your machine? Brilliant! Let's get a sample instance of the Registry up and running locally in no time.</p>"},{"location":"getting-started/#our-first-schema","title":"Our First Schema","text":"<p>Every good story starts with a character, so let's create a simple person schema. Pop this into a file called <code>schemas/person.json</code>:</p> schemas/person.json<pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"title\": \"Person\",\n  \"description\": \"A simple schema for describing a person\",\n  \"type\": \"object\",\n  \"required\": [ \"name\", \"age\" ],\n  \"properties\": {\n    \"age\": { \"type\": \"integer\", \"minimum\": 0 },\n    \"name\": { \"type\": \"string\" }\n  },\n  \"additionalProperties\": false\n}\n</code></pre> <p>Tip</p> <p>We know that working with schemas can be a bit of a maze\u2014authoring, maintaining, debugging, and testing them all have their quirks. For a smoother ride, we highly recommend the open source Sourcemeta JSON Schema CLI as your trusty sidekick, and do bookmark our Learn JSON Schema site for those moments when you need a quick reference on JSON Schema specifics.</p>"},{"location":"getting-started/#configuring-the-registry","title":"Configuring the Registry","text":"<p>Now for the magic ingredient: a configuration file that tells the Registry which schemas to feast upon. Whilst the full configuration documentation covers loads more options, we'll keep things simple here. We're setting our <code>url</code> to <code>http://localhost:8000</code> (where we'll serve our schemas), adding a touch of personality with a custom name in the <code>html</code> section, and creating our very first schema collection called <code>my-first-collection</code>. This collection will gobble up our person schema by pointing to the <code>schemas</code> directory we just created. Save this as <code>registry.json</code> alongside your <code>schemas</code> folder:</p> registry.json<pre><code>{\n  \"url\": \"http://localhost:8000\",\n  \"html\": {\n    \"name\": \"My First Registry\"\n  },\n  \"contents\": {\n    \"my-first-collection\": {\n      \"title\": \"My First Schema Collection\",\n      \"description\": \"I will create more schemas over time here\",\n      \"path\": \"./schemas\"\n    }\n  }\n}\n</code></pre>"},{"location":"getting-started/#writing-a-dockerfile","title":"Writing a <code>Dockerfile</code>","text":"<p>Time to put it all together! Create a <code>Dockerfile</code> with these contents. We're extending the official <code>sourcemeta/registry</code> image from GitHub Packages, copying our configuration file and schemas directory into the container, and then running the indexing process with the <code>sourcemeta</code> command. Simple as that!</p> Dockerfile<pre><code>FROM ghcr.io/sourcemeta/registry:3.2\nCOPY registry.json .\nCOPY schemas schemas\nRUN sourcemeta registry.json\n</code></pre>"},{"location":"getting-started/#running-locally","title":"Running Locally","text":"<p>Right, we're all set! Let's build our Docker image (we'll call it <code>my-first-registry</code>) and fire up the Registry. The Registry serves on port 8000 by default, so we'll expose that:</p> <pre><code>$ docker build --tag my-first-registry . --file Dockerfile\n$ docker run --publish 8000:8000 my-first-registry\n</code></pre> <p>Now head over to http://localhost:8000 in your favourite web browser, and you'll be greeted by your very own instance:</p> <p></p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've just built your first Sourcemeta Registry in under two minutes (told you so!). Whilst our single-schema registry might seem modest, you've got the perfect foundation to experiment and expand.</p> <p>Ready to take things further? Take a look at our integrations which cover ways on which you can pull and use the schemas in a growing amount of programming languages and applications.</p> <p>We also recommend exploring the full range of options in the Registry configuration file, discovering how to import ready-made schema collections through our built-in schema library, exploring the HTTP API, and having a peek at schemas.sourcemeta.com to see what a fully-fledged public instance looks like in the wild.</p>"},{"location":"getting-started/#using-docker","title":"Using Docker","text":"<p>The Sourcemeta Registry is exclusively distributed as Docker images published to GitHub Packages. We provide multi-architecture images supporting both x64 and arm64 platforms, ensuring compatibility across different systems whilst maintaining consistent behaviour. Docker is the only officially supported method for running the Registry and we do not provide platform-specific binaries for individual operating systems.</p> <p>To run the Registry, create a <code>Dockerfile</code> that extends our base image and follows the build pattern shown below:</p> Dockerfile<pre><code># See https://github.com/orgs/sourcemeta/packages?repo_name=registry\nFROM ghcr.io/sourcemeta/registry:&lt;version&gt;\n\n# (2) Copy your configuration file and schemas to the *working directory*\n# Avoid copying files to other paths outside the working directory, as\n# the indexer will not automatically clean them up for you if so!\n# See https://registry.sourcemeta.com/configuration/\nCOPY registry.json .\nCOPY schemas schemas\n\n# (3) Run the Registry build step on your input configuration file\n# The indexer will automatically remove the input schemas from the\n# working directory to keep the image lean\nRUN sourcemeta registry.json\n</code></pre> <p>The build process follows a straightforward pattern: extend the base image, copy your configuration and schema files into the working directory, and run the indexing command. The indexer automatically removes source schemas after processing to keep the final image size minimal.</p>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"<p>The Registry can be configured using the following runtime environment variables.</p> Name Default Description <code>SOURCEMETA_REGISTRY_PORT</code> <code>8000</code> The HTTP port on which the Registry will listen on"},{"location":"getting-started/#using-docker-compose","title":"Using Docker Compose","text":"<p>For more complex deployments or when integrating the Registry alongside other services, Docker Compose provides a convenient orchestration method. The following example demonstrates a basic setup that builds your Registry image and exposes it on the desired port:</p> compose.yaml<pre><code>services:\n  registry:\n    build:\n      # The Dockerfile that extends the Registry base image\n      dockerfile: Dockerfile\n      context: .\n    environment:\n      # Set your desired port\n      - SOURCEMETA_REGISTRY_PORT=8000\n    ports:\n      # Expose the ports accordingly\n      - \"8000:8000\"\n</code></pre> <p>This configuration builds your custom Registry image using the <code>Dockerfile</code> in the current directory and maps the container's port to your host system. You can extend this setup to include additional services, networks, or volumes as needed for your specific deployment requirements.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>We aim for the Sourcemeta Registry to seamlessly integrate with as many applications and ecosystems as possible. Its HTTP API provides a robust foundation for custom integrations, and we are always eager to hear more about use cases that demand a more direct integration. If you have any ideas, please reach out on GitHub Discussions!</p>"},{"location":"integrations/#languages","title":"Languages","text":""},{"location":"integrations/#deno","title":"Deno","text":"<p>The Sourcemeta Registry supports Deno HTTPS imports, allowing you to directly import schema definitions (along with their dependencies, if any) into your programs.</p> <p>Zero-Config Dependency Resolution</p> <p>Forget about manually managing schema dependencies! The Registry intelligently detects Deno <code>import</code> requests and automatically serves bundled schemas with all <code>$ref</code> dependencies pre-resolved. What used to require complex dependency management now happens seamlessly behind the scenes.</p> <p>To pull a JSON Schema into a Deno program, using a JSON <code>import</code> pointing to the schema URL. In this case, replace <code>registry.example.com</code> with your Registry URL and <code>my/schema.json</code> with the path to the schema you want to import.</p> main.js<pre><code>import schema from \"https://registry.example.com/my/schema.json\" with { type: \"json\" };\nconsole.log(schema);\n</code></pre> <p>Then, run the program using the <code>--allow-import</code> permission.</p> <pre><code>deno run --allow-import main.js\n</code></pre> <p>Deno will download and cache the schema on the first run. To force Deno to query the Registry again, use the <code>--reload</code> option:</p> <pre><code>deno run --allow-import --reload main.js\n</code></pre>"},{"location":"integrations/#specifications","title":"Specifications","text":""},{"location":"integrations/#openapi","title":"OpenAPI","text":"<p>OpenAPI specifications may directly reference schemas from the Registry using the <code>$ref</code> keyword. For example:</p> openapi.yaml<pre><code>openapi: 3.1.0\ninfo:\n  title: My API\n  version: 1.0.0\npaths:\n  /users:\n    post:\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: \"https://registry.example.com/schemas/user.json\"\n      responses:\n        '201':\n          description: User created\n          content:\n            application/json:\n              schema:\n                $ref: \"https://registry.example.com/schemas/user.json\"\n</code></pre> <p>On distribution, you should bundle the OpenAPI specification to automatically fetch and embed external schema references. This is how you can do it using the popular Redocly CLI:</p> <pre><code>redocly bundle path/to/openapi.yaml\n</code></pre> <p>Tip</p> <p>This is a powerful strategy to have a growing amount of APIs defined using a single source of truth of data definitions. Bundling allows you get a self-contained OpenAPI specification for distribution that won't require further network requests to resolve, whilst allowing you to maintain clean separation between your API definitions and reusable schemas during development.</p>"},{"location":"integrations/#editors","title":"Editors","text":""},{"location":"integrations/#visual-studio-code","title":"Visual Studio Code","text":"<p>The Sourcemeta Registry offers improved Visual Studio Code schema auto-completion support. It does this by automatically serving the editor with transformed schemas (without loss of semantics) that aim to workaround its significant compliance issues that prevent many schemas from working correctly.</p> <p>The key limitations that the Registry aims to workaround include:</p> <ul> <li> <p>Missing support for <code>$id</code> (and its older <code>id</code> counter-part). This affects   auto-completion of bundled or complex schemas. See   <code>microsoft/vscode-json-languageservice#224</code></p> </li> <li> <p>Missing support for <code>$dynamicRef</code>. This affects meta-schema auto-completion.   See   <code>microsoft/vscode-json-languageservice#149</code></p> </li> </ul> <p>Note</p> <p>Whilst this compatibility layer significantly improves Visual Studio Code auto-completion support, some advanced schema features may still not work due to fundamental limitations in their implementation. The ultimate solution is fixing the editor's compliance, which is of course outside of our control</p>"},{"location":"library/","title":"Curated Schema Collections","text":"<p>Most JSON Schema projects don't start from a blank sheet. They often build on top of existing data models for regulatory compliance, partner interoperability, or simply to avoid reinventing the wheel.</p> <p>However, hunting down the right authoritative source, copying schemas from multiple sources, and keeping them aligned with the versions your consumers expect is time-consuming and error-prone. That friction increases delivery risk, introduces compatibility bugs, and makes governance much harder than it needs to be.</p> <p>To solve this problem, the Sourcemeta Registry ships with a growing curated set of widely-used JSON Schema collections that you can easily import into your instance. Each collection is discoverable, versioned, and maintained so you don't have to stitch together third-party copies or worry about minor drift between consumers. Importing a collection gives you an immediately usable, validated set of schemas you can reference and extend.</p> <p>Tip</p> <p>Every available built-in collection is ingested in the schemas.sourcemeta.com live example instance. We also ingest other collections to mature their definitions in such instance before they graduate as a built-in collection. Go take a look and checkout its <code>registry.json</code> configuration file!</p>"},{"location":"library/#importing-collections","title":"Importing Collections","text":"<p>Each built-in schema collection has with a unique identifier that starts with the <code>@</code> character. To import such a collection, import the corresponding identifier to your configuration file using the <code>extends</code> keyword.</p> <p>For example, let's say your company depends on GeoJSON v1.0.5 and v1.0.4. Their identifiers are <code>@geojson/v1.0.5</code> and <code>@geojson/v1.0.4</code>, respectively. Therefore, a minimal example configuration that ingests them both using the <code>extends</code> keyword may look like this:</p> registry.json<pre><code>{\n  \"url\": \"https://schemas.example.com\",\n  \"extends\": [ \"@geojson/v1.0.5\", \"@geojson/v1.0.4\" ]\n}\n</code></pre> <p>Other schemas in your instance may reference these GeoJSON schemas using their absolute URLs (i.e. <code>https://schemas.example.com/geojson/v1.0.5/point.json</code>) or.  relative URLs (i.e. <code>/geojson/v1.0.5/point.json</code>). You can also re-route existing schemas into the imported locations using the <code>resolve</code> configuration option.</p>"},{"location":"library/#available-collections","title":"Available Collections","text":"<p>These collections are available in every edition of the Sourcemeta Registry (including the free one) <sup>1</sup>.  Simply add the corresponding identifier to your configuration file using the <code>extends</code> keyword.</p> Identifier Source Description Preview <code>@geojson/v1.0.5</code> GeoJSON A standard format (RFC 7946) for encoding a variety of geographic data structures Link <code>@geojson/v1.0.4</code> GeoJSON A standard format (RFC 7946) for encoding a variety of geographic data structures Link <code>@geojson/v1.0.3</code> GeoJSON A standard format (RFC 7946) for encoding a variety of geographic data structures Link <code>@geojson/v1.0.2</code> GeoJSON A standard format (RFC 7946) for encoding a variety of geographic data structures Link <code>@geojson/v1.0.1</code> GeoJSON A standard format (RFC 7946) for encoding a variety of geographic data structures Link <code>@geojson/v1.0.0</code> GeoJSON A standard format (RFC 7946) for encoding a variety of geographic data structures Link <code>@modelcontextprotocol/2025-06-18</code> Model Context Protocol (MCP) An open protocol that standardizes how applications provide context to large language models (LLMs) Link <code>@modelcontextprotocol/2025-03-26</code> Model Context Protocol (MCP) An open protocol that standardizes how applications provide context to large language models (LLMs) Link <code>@modelcontextprotocol/2024-11-05</code> Model Context Protocol (MCP) An open protocol that standardizes how applications provide context to large language models (LLMs) Link <code>@a2a/v0.3.0</code> Agent2Agent (A2A) Protocol An open standard designed to enable seamless communication and collaboration between AI agents Link <code>@a2a/v0.2.6</code> Agent2Agent (A2A) Protocol An open standard designed to enable seamless communication and collaboration between AI agents Link <code>@a2a/v0.2.5</code> Agent2Agent (A2A) Protocol An open standard designed to enable seamless communication and collaboration between AI agents Link <code>@a2a/v0.2.4</code> Agent2Agent (A2A) Protocol An open standard designed to enable seamless communication and collaboration between AI agents Link <code>@a2a/v0.2.3</code> Agent2Agent (A2A) Protocol An open standard designed to enable seamless communication and collaboration between AI agents Link <code>@a2a/v0.2.2</code> Agent2Agent (A2A) Protocol An open standard designed to enable seamless communication and collaboration between AI agents Link <code>@a2a/v0.2.1</code> Agent2Agent (A2A) Protocol An open standard designed to enable seamless communication and collaboration between AI agents Link <code>@a2a/v0.2.0</code> Agent2Agent (A2A) Protocol An open standard designed to enable seamless communication and collaboration between AI agents Link <code>@sdf/v1.0.0</code> Semantic Definition Format (SDF) A format for domain experts to use in the creation and maintenance of data and interaction models that describe Things Link <code>@openapi/v3.2</code> OpenAPI The world's most widely used API description standard Link <code>@openapi/v3.1</code> OpenAPI The world's most widely used API description standard Link <code>@openapi/v3.0</code> OpenAPI The world's most widely used API description standard Link <code>@openapi/v2.0</code> OpenAPI The world's most widely used API description standard Link <code>@sourcemeta/registry</code> Sourcemeta Registry Schemas that define the Sourcemeta Registry itself Link <code>@sourcemeta/std</code> Sourcemeta Standard Library The Sourcemeta JSON Schema Standard Library Link"},{"location":"library/#requesting-new-collections","title":"Requesting New Collections","text":"<p>To request the addition of a new built-in collection, or a new version of an existing collection, please open an issue on GitHub. Or if you are feeling adventurous, you may send a pull request to contribute it to the <code>collections/</code> folder.</p> <p>Info</p> <p>Not having a collection as part of the built-in library doesn't lock you out. You can always bring any collection into your instance yourself by cloning or downloading the collection's repository, and manually ingesting it into the Registry using the configuration file. Built-in collections are nothing more than pre-made configuration files we pre-package for you.</p> <ol> <li> <p>The built-in collections we offer are redistributed directly from their   upstream sources without modification. As such, any issues, errors, or   requests for changes should be directed to the original project maintainers.\u00a0\u21a9</p> </li> </ol>"}]}